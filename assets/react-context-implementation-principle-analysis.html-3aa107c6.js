import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as p,c as l,a as i,b as n,d as s,e,f as t}from"./app-8be8ff26.js";const d={},r=n("p",null,[n("strong",null,"本文由我和ChatGTP联合共创，参考资料在文末，如有勘误请指出，如有侵权请联系我删除，谢谢！"),n("img",{src:"http://qncdn.yunishare.cn/blog/react-context.png@water",alt:"image.png",loading:"lazy"})],-1),u=n("h3",{id:"什么是-react-context",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#什么是-react-context","aria-hidden":"true"},"#"),s(" 什么是 React Context？")],-1),k=n("p",null,[n("code",null,"Context"),s(" 是 "),n("code",null,"React"),s(" 提供的一种跨层级组件通信的机制，它允许你在组件树中共享数据，而不必手动通过 "),n("code",null,"props"),s(" 一层层传递。")],-1),v=t(`<p>我们通常使用 <code>props</code> 将数据显式传递到使用它的组件，这是组件数据传递最好的方式。但是当我们需要在组件树中深层传递参数，逐层传递 <code>props</code> 就会变得很麻烦。</p><p>那有没有一种方式可以将数据直达所需要的组件中，而不需要层层传递呢？<code>React</code> 的 <code>Context</code> 就能满足我们的这个需求。使用<code>Context</code>我们可以将数据传递到任何需要使用他的子组件中，而不需要额外的声明<code>props</code>。</p><h3 id="context-api-概览及使用" tabindex="-1"><a class="header-anchor" href="#context-api-概览及使用" aria-hidden="true">#</a> Context API 概览及使用</h3><p><code>Context</code> 主要由三个部分组成：<code>React.createContext</code> 方法、<code>Context.Provider</code> 组件和 <code>Context.Consumer</code> 组件。</p><h4 id="定义context-react-createcontext" tabindex="-1"><a class="header-anchor" href="#定义context-react-createcontext" aria-hidden="true">#</a> <strong>定义Context - React.createContext ：</strong></h4><p>是一个用于创建 <code>Context</code> 对象的方法。它接收一个默认值作为参数，并返回一个包含 <code>Provider</code> 和 <code>Consumer</code> 组件的对象。默认值在组件树中找不到匹配的 <code>Provider</code> 时被使用。</p><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token comment">// 创建一个名为 MyContext 的 Context 对象，并指定默认值为 &quot;default value&quot;</span>
<span class="token keyword">const</span> MyContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">&quot;default value&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="赋值context-context-provider-组件" tabindex="-1"><a class="header-anchor" href="#赋值context-context-provider-组件" aria-hidden="true">#</a> <strong>赋值Context - Context.Provider 组件：</strong></h4><p><code>Context.Provider</code> 是用于提供数据的组件，它接收一个 <code>value</code> 属性作为数据的值。<code>Provider</code> 组件将 value 中的数据传递给其子组件中的所有 <code>Consumer</code> 组件。当 <code>Provider</code> 的 <code>value</code> 发生变化时，所有依赖该 <code>Provider</code> 的 <code>Consumer</code> 组件都会重新渲染。</p><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> MyContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./MyContext&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用 MyContext.Provider 提供共享数据</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyContext.Provider</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Hello from Context<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ChildComponent</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">MyContext.Provider</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="消费context-context-consumer-组件" tabindex="-1"><a class="header-anchor" href="#消费context-context-consumer-组件" aria-hidden="true">#</a> <strong>消费Context - Context.Consumer 组件：</strong></h4><p><code>Context.Consumer</code> 组件用于在组件树中消费共享的数据。它必须包含在 <code>Context.Provider </code>内部，并且使用函数作为其子元素。这个函数接收当前的 <code>Context</code> 值作为参数，并返回 <code>React</code> 元素。当 <code>Context.Provider</code> 的 <code>value</code> 发生变化时，<code>Context.Consumer</code> 组件会重新渲染，获取最新的 <code>Context</code> 值。<br><code>Consumer</code> 组件通过函数作为子组件的方式，将 <code>Provider</code> 提供的值作为该函数的参数，可以在函数体内使用该值。</p><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> MyContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./MyContext&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">ChildComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用 MyContext.Consumer 消费共享数据</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyContext.Consumer</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">MyContext.Consumer</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="使用-usecontext-钩子简化-context-的消费" tabindex="-1"><a class="header-anchor" href="#使用-usecontext-钩子简化-context-的消费" aria-hidden="true">#</a> 使用 useContext 钩子简化 <strong>Context 的消费</strong></h4><p><code>React</code> 16.8 引入了 <code>useContext hooks</code>，我们可以通过使用 <code>useContext hook</code> 简化 <code>Context</code> 的使用。以上面<code>Consumer</code> 消费的例子为例，使用 <code>useContext</code> 可以这样写：</p><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> MyContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./MyContext&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">ChildComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>MyContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，<code>useContext(MyContext) </code>的调用会返回 <code>MyContext</code> 的当前值，然后可以直接在组件中使用该值。<code>useContext</code> 的好处在于简化了代码，消除了嵌套的 <code>Context.Consumer</code> 组件，使得组件的代码更加简洁和易读。<br>需要注意，<code>useContext</code> 只能用于函数组件中，并且只能用于获取一个 <code>Context</code> 对象的值。如果需要获取多个 <code>Context</code> 对象的值，仍然需要使用多个 <code>useContext</code>。</p><p>通过 <code>Context API</code>，我们可以在组件树中方便地共享数据，避免了逐层传递 props 的繁琐。使用 <code>React.createContext()</code> 方法创建 <code>Context</code> 对象，<code>Context.Provider</code> 提供数据，而 <code>Context.Consumer</code> / <code>useContext</code> 消费数据，这样可以轻松实现跨组件层级的数据传递。</p><h3 id="react-context-的实现原理" tabindex="-1"><a class="header-anchor" href="#react-context-的实现原理" aria-hidden="true">#</a> React Context 的实现原理</h3><h4 id="数据结构-context-对象" tabindex="-1"><a class="header-anchor" href="#数据结构-context-对象" aria-hidden="true">#</a> 数据结构：Context 对象</h4><figure><img src="http://qncdn.yunishare.cn/blog/console-context.png@water" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">createContext</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>defaultValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> ReactContext<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 源码中context对象</span>
  <span class="token keyword">const</span> context<span class="token operator">:</span> ReactContext<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_CONTEXT_TYPE</span><span class="token punctuation">,</span>
    _calculateChangedBits<span class="token operator">:</span> calculateChangedBits<span class="token punctuation">,</span>
    <span class="token comment">// As a workaround to support multiple concurrent renderers, we categorize</span>
    <span class="token comment">// some renderers as primary and others as secondary. We only expect</span>
    <span class="token comment">// there to be two concurrent renderers at most: React Native (primary) and</span>
    <span class="token comment">// Fabric (secondary); React DOM (primary) and React ART (secondary).</span>
    <span class="token comment">// Secondary renderers store their context values on separate fields.</span>
    _currentValue<span class="token operator">:</span> defaultValue<span class="token punctuation">,</span>
    _currentValue2<span class="token operator">:</span> defaultValue<span class="token punctuation">,</span>
    <span class="token comment">// Used to track how many concurrent renderers this context currently</span>
    <span class="token comment">// supports within in a single renderer. Such as parallel server rendering.</span>
    _threadCount<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token comment">// These are circular</span>
    Provider<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Consumer<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  context<span class="token punctuation">.</span>Provider <span class="token operator">=</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_PROVIDER_TYPE</span><span class="token punctuation">,</span>
    _context<span class="token operator">:</span> context<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token operator">...</span><span class="token operator">...</span>
  context<span class="token punctuation">.</span>Consumer <span class="token operator">=</span> context<span class="token punctuation">;</span>
  <span class="token keyword">return</span> context<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,22),m={href:"https://github.com/facebook/react/blob/17.0.2/packages/react/src/ReactContext.js",target:"_blank",rel:"noopener noreferrer"},x=n("code",null,"React Context ",-1),b=n("code",null,"JavaScript",-1),g=n("code",null,"Provider",-1),h=n("code",null,"Consumer",-1),C=n("code",null,"Provider",-1),_=n("code",null,"Consumer",-1),f=n("br",null,null,-1),y=n("code",null,"_currentValue",-1),R=n("code",null,"_currentValue2",-1),P=n("code",null,"createContext",-1),w=n("code",null,"defaultValue",-1),M=n("code",null,"_currentValue",-1),V=n("code",null,"Provider",-1),F=n("code",null,"value",-1),T=n("code",null,"2",-1),j=n("code",null,"value",-1),q=n("br",null,null,-1),S=n("code",null,"context",-1),E=t('<ol><li>实例化<code>context</code>，并将默认值<code>defaultValue</code>赋值给<code>context._currentValue</code></li><li>每遇到一个同类型<code>context.Provier</code>，将value赋值给<code>context._currentValue</code></li><li><code>Consumer</code> / <code>useContext</code>取<code>context._currentValue</code>上的值</li></ol><p>通过上述流程我们可以看出，<code>Context</code>的核心实现主要是步骤<code>2</code>，即<code>value</code>值的更新。</p><h4 id="context-的更新与触发-基于-fiber-架构的实现" tabindex="-1"><a class="header-anchor" href="#context-的更新与触发-基于-fiber-架构的实现" aria-hidden="true">#</a> Context 的更新与触发-基于 Fiber 架构的实现</h4><blockquote><p>当 <code>Provider</code> 的值发生变化时，React 会重新渲染与之相关的所有 <code>Consumer</code> 组件。这是通过一种叫做“订阅/发布模式”（<code>Publish/Subscribe</code>）的机制实现的。<code>Provider</code> 组件维护一个订阅列表，当值发生变化时，会通知订阅了该 <code>Provider</code> 的所有 <code>Consumer</code> 组件，触发它们的重新渲染。—ChatGTP如是一本正经的说（这一点感觉它说的不太对，感觉是在瞎编糊弄我呢😂）</p></blockquote><p>React Fiber 架构对于 <code>Context</code> 的实现起到了重要的作用。在 <code>Fiber</code> 架构下，<code>React</code> 使用单链表的数据结构来表示组件树，这样可以更高效地进行协调和更新。当 <code>Provider</code> 的值发生变化时，<code>React</code> 会通过遍历 Fiber 树的方式，找到所有依赖于该 <code>Provider</code> 的节点，并触发它们的重新渲染。</p>',5),A={href:"https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberNewContext.new.js#L182",target:"_blank",rel:"noopener noreferrer"},D=t('<ul><li>向下遍历: 从<code>ContextProvider</code>类型的节点开始, 向下查找所有<code>fiber.dependencies</code>依赖该<code>context</code>的节点(<code>consumer</code>).</li><li>向上遍历: 从<code>consumer</code>节点开始, 向上遍历（每个子元素都引用了父节点）, 修改父路径上所有节点的<code>fiber.childLanes</code>属性, 表明其子节点有改动, 子节点会进入更新逻辑.</li></ul><figure><img src="http://qncdn.yunishare.cn/blog/fiber-constructor-tree.png@water" alt="fiber树" tabindex="0" loading="lazy"><figcaption>fiber树</figcaption></figure><h5 id="主要更新步骤" tabindex="-1"><a class="header-anchor" href="#主要更新步骤" aria-hidden="true">#</a> 主要更新步骤：</h5>',3),N=n("li",null,[s("当 "),n("code",null,"Context"),s(" 的值发生变化时，"),n("code",null,"React"),s(" 会触发 "),n("code",null,"Context"),s(" 的更新，来更新 "),n("code",null,"Provider"),s(" 组件的状态。")],-1),L=n("code",null,"Provider",-1),O={href:"https://github.com/facebook/react/blob/17.0.2/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L506",target:"_blank",rel:"noopener noreferrer"},z=n("code",null,"Context",-1),I=n("code",null,"Fiber",-1),B=t("<li>在 <code>React</code> 的调度过程中，<code>React</code> 会遍历“脏”状态的 <code>Fiber</code> 节点，并进行协调和更新操作。对于依赖于 <code>Context</code> 的 <code>Consumer</code> 组件，会触发它们的重新渲染。在遍历过程中，React 会根据 Fiber 节点的类型，调用对应的更新函数（如函数组件的 <code>updateFunctionComponent</code>、类组件的 <code>updateClassComponent</code>）。</li><li>在更新函数中，<code>React</code> 会检查 <code>Consumer</code> 组件是否依赖于发生变化的 <code>Context</code>。如果依赖的 <code>Context</code> 发生了更新，React 会标记 <code>Consumer</code> 对应的 Fiber 节点为“脏”状态，触发重新渲染。</li><li>在协调和更新过程完成后，<code>React</code> 会进行提交阶段，将新的 Fiber 树的变更应用到实际的 DOM 中。在<code>commit</code>提交阶段，React 会遍历 <code>Fiber</code> 树，并根据 <code>Fiber</code> 节点的类型执行不同的操作，如创建新的 <code>DOM</code> 节点、更新属性、插入、移动或删除 <code>DOM</code> 节点等。在更新过程中，<code>React</code> 会将新的 <code>Fiber</code> 树与旧的 <code>Fiber</code> 树进行比较和交换（diff算法），确保更新是以高效的方式进行的。</li>",3),U=t(`<h4 id="嵌套组件的数据生产-更新-和消费" tabindex="-1"><a class="header-anchor" href="#嵌套组件的数据生产-更新-和消费" aria-hidden="true">#</a> 嵌套组件的数据生产（更新）和消费</h4><div class="language-tsx line-numbers-mode" data-ext="tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> MyContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyContext.Provider</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyContext.Provider</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyContext.Provider</span></span> <span class="token attr-name">value</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child1</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">MyContext.Provider</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child2</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">MyContext.Provider</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child3</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">MyContext.Provider</span></span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面代码中，<code>MyContext</code> 的值会从默认值0，逐渐被更新为<code>1</code>、<code>2</code>、<code>3</code>，沿途消费的<code>Child</code>组件取得的值分别为：<code>3</code>、<code>2</code>、<code>1</code>。整个后进先出的流程很像栈（其实就是）：<code>1</code>、<code>2</code>、<code>3</code>分别入栈，<code>3</code>、<code>2</code>、<code>1</code>分别出栈，过程中栈顶的值就是<code>context</code>当前的值。</p><figure><img src="http://qncdn.yunishare.cn/blog/stack-context.png@water" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>实现这种嵌套的机制，React 利用的就是是栈的特性（后进先出），通过 <code>pushProvider</code> 方法进行入栈 和 <code>popProvider</code>方法进行出栈。<br>每次执行<code>pushProvider</code>时将<code>context._currentValue</code>更新为当前值：使用<code>push</code> 方法将 <code>cursor.current</code> 的值推到 <code>valueStack</code> 的栈顶，然后把当前 <code>provider</code> 节点的变化了的 <code>value</code> 值放到 <code>cursor.current</code> 中。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 使用栈存储 context._currentValue 值</span>
<span class="token keyword">function</span> <span class="token function">pushProvider</span><span class="token punctuation">(</span>providerFiber<span class="token punctuation">,</span> context<span class="token punctuation">,</span> nextValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 入栈</span>
  <span class="token function">push</span><span class="token punctuation">(</span>valueCursor<span class="token punctuation">,</span> context<span class="token punctuation">.</span>_currentValue<span class="token punctuation">,</span> providerFiber<span class="token punctuation">)</span>
  <span class="token comment">// 修改 context 的值</span>
  context<span class="token punctuation">.</span>_currentValue <span class="token operator">=</span> nextValue
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">push</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>cursor<span class="token operator">:</span> StackCursor<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> fiber<span class="token operator">:</span> Fiber<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  index<span class="token operator">++</span><span class="token punctuation">;</span>
	
  valueStack<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> cursor<span class="token punctuation">.</span>current<span class="token punctuation">;</span>

  <span class="token comment">// ...</span>
  
	<span class="token comment">// 保存最新值</span>
  cursor<span class="token punctuation">.</span>current <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="http://qncdn.yunishare.cn/blog/fiber-stack.png@water" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p><code>popProvider</code>出栈操作执行时，会将<code>context._currentValue</code>更新为上一个<code>context._currentValue</code>：<code>pop</code> 方法则将 <code>cursor.current</code> 的值替换成 <code>valueStack</code> 栈顶的值，然后栈顶的值重置为 <code>null</code>，接着 <code>index--</code>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">popProvider</span><span class="token punctuation">(</span>
  context<span class="token operator">:</span> ReactContext<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  providerFiber<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  
  <span class="token keyword">const</span> currentValue <span class="token operator">=</span> valueCursor<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
 	context<span class="token punctuation">.</span>_currentValue <span class="token operator">=</span> currentValue<span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
  <span class="token function">pop</span><span class="token punctuation">(</span>valueCursor<span class="token punctuation">,</span> providerFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">pop</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>cursor<span class="token operator">:</span> StackCursor<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> fiber<span class="token operator">:</span> Fiber<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
	<span class="token comment">// 取出栈顶元素</span>
  cursor<span class="token punctuation">.</span>current <span class="token operator">=</span> valueStack<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>

  valueStack<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token comment">// ...</span>
  index<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-context-的性能优化" tabindex="-1"><a class="header-anchor" href="#_4-context-的性能优化" aria-hidden="true">#</a> 4. Context 的性能优化</h3><p>在大型应用中，<code>React Context</code> 可能会面临性能问题，主要涉及以下几个方面：</p><ul><li><strong>嵌套层级过深</strong>：当 <code>Context</code> 嵌套层级过深时，每个 <code>Consumer</code> 组件在渲染时都需要检查其上层是否存在匹配的 Provider 组件。这种嵌套关系会增加渲染的开销，特别是在庞大的组件树中。</li><li><strong>未优化的更新触发</strong>：如果 <code>Context</code> 的值发生变化时，所有依赖该 <code>Context</code> 的 <code>Consumer</code> 组件都会触发重新渲染。在某些情况下，这可能会导致无关的组件重新渲染，造成性能浪费。</li></ul><p>针对这些性能问题，可以采取以下优化策略：</p><ol><li><strong>避免过深的嵌套层级</strong>：尽量避免在组件树中创建过深的 <code>Context</code> 嵌套结构。可以通过重构组件结构、合并多个 <code>Context</code>，或者使用更细粒度的 <code>Context</code> 来减少嵌套层级。</li><li><strong>使用 shouldComponentUpdate 或 React.memo</strong>：在 <code>Consumer</code> 组件中，可以使用 <code>shouldComponentUpdate</code> 或 <code>React.memo</code> 来进行性能优化。通过对比前后的 <code>Context</code> 值，可以避免不必要的重新渲染。</li><li><strong>使用 useContext 和 useReducer</strong>：在性能要求较高的情况下，可以使用 <code>useContext</code> 配合 <code>useReducer</code> 来替代 <code>useContext</code> 配合 <code>useState</code>。因为 <code>useReducer</code> 提供了更细粒度的更新控制，可以减少不必要的重新渲染。</li><li><strong>使用局部化的 Context</strong>：对于大型应用中的某些模块或功能，可以使用局部化的 <code>Context</code>，而不是将 <code>Context</code> 放置在整个应用的顶层。这样可以减少不必要的 <code>Consumer</code> 组件，提高渲染性能。</li><li><strong>使用数据分离</strong>：对于只读的全局数据，可以考虑使用状态管理库（如 <code>Redux</code> 或 <code>MobX</code>）来管理，而不是使用 <code>Context</code>。这样可以提供更高效的状态管理和更新机制。</li></ol><p>性能优化应该根据具体的应用场景和需求进行评估和实施。在进行优化时，可以使用性能分析工具（如 <code>React DevTools</code> 和 <code>Chrome DevTools</code>）来定位性能瓶颈，并针对性地进行调整。</p><h3 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h3>`,16),$=n("li",null,"Chatgtp 对话",-1),X={href:"https://react.docschina.org/learn/scaling-up-with-reducer-and-context",target:"_blank",rel:"noopener noreferrer"},G={href:"https://github.com/facebook/react/tree/17.0.2",target:"_blank",rel:"noopener noreferrer"},H={href:"https://juejin.cn/post/7213752661761523772",target:"_blank",rel:"noopener noreferrer"},Q={href:"https://7km.top/main/context",target:"_blank",rel:"noopener noreferrer"},W={href:"https://mp.weixin.qq.com/s/qpQS3ne7HXSL5Dle-ts4qQ",target:"_blank",rel:"noopener noreferrer"};function Y(J,K){const a=c("ExternalLinkIcon");return p(),l("div",null,[r,u,k,i("more"),v,n("p",null,[s("从 "),n("a",m,[s("ReactContext.js 源码"),e(a)]),s("中可以看出，"),x,s("是一个 "),b,s(" 对象，它包含了两个属性："),g,s(" 和 "),h,s("。"),C,s(" 组件用于提供数据，"),_,s(" 组件用于消费数据。"),f,s("同时还有两个变量 "),y,s(" 和"),R,s(" 用来储存值，默认取"),P,s(" 创建时传入得 "),w,s("。"),M,s(" 主要用来保存传递给"),V,s("的"),F,s("属性值。从注释可以看出, 保存 "),T,s(" 个 "),j,s(" 是为了支持多个渲染器并发渲染。"),q,S,s("工作流程可以概括为三个步骤：")]),E,n("p",null,[s("其主要更新逻辑在 "),n("a",A,[s("propagateContextChange"),e(a)]),s("方法：")]),D,n("ol",null,[N,n("li",null,[L,s(" 组件的状态更新完成后，会调用 ReactFiber 中的 "),n("a",O,[s("scheduleUpdateOnFiber(markRootUpdated)"),e(a)]),s(" 方法来标记 "),z,s(" 相关的 "),I,s(" 节点为“脏”状态，表示需要重新渲染。")]),B]),U,n("ol",null,[$,n("li",null,[n("a",X,[s("React 官方文档"),e(a)])]),n("li",null,[n("a",G,[s("React github 源码"),e(a)])]),n("li",null,[n("a",H,[s("深入 React Context 源码与实现"),e(a)])]),n("li",null,[n("a",Q,[s("Context原理"),e(a)])]),n("li",null,[n("a",W,[s("React Context的核心实现，就5行代码"),e(a)])])])])}const sn=o(d,[["render",Y],["__file","react-context-implementation-principle-analysis.html.vue"]]);export{sn as default};
